{"version":3,"file":"y-memory.js","sources":["src/RedBlackTree.js","src/y-memory.js"],"sourcesContent":["\n/*\n  This file contains a not so fancy implemantion of a Red Black Tree.\n*/\nexport default function extendRBTree (Y) {\n  class N {\n    // A created node is always red!\n    constructor (val) {\n      this.val = val\n      this.color = true\n      this._left = null\n      this._right = null\n      this._parent = null\n      if (val.id === null) {\n        throw new Error('You must define id!')\n      }\n    }\n    isRed () { return this.color }\n    isBlack () { return !this.color }\n    redden () { this.color = true; return this }\n    blacken () { this.color = false; return this }\n    get grandparent () {\n      return this.parent.parent\n    }\n    get parent () {\n      return this._parent\n    }\n    get sibling () {\n      return (this === this.parent.left)\n        ? this.parent.right : this.parent.left\n    }\n    get left () {\n      return this._left\n    }\n    get right () {\n      return this._right\n    }\n    set left (n) {\n      if (n !== null) {\n        n._parent = this\n      }\n      this._left = n\n    }\n    set right (n) {\n      if (n !== null) {\n        n._parent = this\n      }\n      this._right = n\n    }\n    rotateLeft (tree) {\n      var parent = this.parent\n      var newParent = this.right\n      var newRight = this.right.left\n      newParent.left = this\n      this.right = newRight\n      if (parent === null) {\n        tree.root = newParent\n        newParent._parent = null\n      } else if (parent.left === this) {\n        parent.left = newParent\n      } else if (parent.right === this) {\n        parent.right = newParent\n      } else {\n        throw new Error('The elements are wrongly connected!')\n      }\n    }\n    next () {\n      if (this.right !== null) {\n        // search the most left node in the right tree\n        var o = this.right\n        while (o.left !== null) {\n          o = o.left\n        }\n        return o\n      } else {\n        var p = this\n        while (p.parent !== null && p !== p.parent.left) {\n          p = p.parent\n        }\n        return p.parent\n      }\n    }\n    prev () {\n      if (this.left !== null) {\n        // search the most right node in the left tree\n        var o = this.left\n        while (o.right !== null) {\n          o = o.right\n        }\n        return o\n      } else {\n        var p = this\n        while (p.parent !== null && p !== p.parent.right) {\n          p = p.parent\n        }\n        return p.parent\n      }\n    }\n    rotateRight (tree) {\n      var parent = this.parent\n      var newParent = this.left\n      var newLeft = this.left.right\n      newParent.right = this\n      this.left = newLeft\n      if (parent === null) {\n        tree.root = newParent\n        newParent._parent = null\n      } else if (parent.left === this) {\n        parent.left = newParent\n      } else if (parent.right === this) {\n        parent.right = newParent\n      } else {\n        throw new Error('The elements are wrongly connected!')\n      }\n    }\n    getUncle () {\n      // we can assume that grandparent exists when this is called!\n      if (this.parent === this.parent.parent.left) {\n        return this.parent.parent.right\n      } else {\n        return this.parent.parent.left\n      }\n    }\n  }\n\n  class RBTree {\n    constructor () {\n      this.root = null\n      this.length = 0\n    }\n    * findNext (id) {\n      return yield * this.findWithLowerBound([id[0], id[1] + 1])\n    }\n    * findPrev (id) {\n      return yield * this.findWithUpperBound([id[0], id[1] - 1])\n    }\n    findNodeWithLowerBound (from) {\n      if (from === void 0) {\n        throw new Error('You must define from!')\n      }\n      var o = this.root\n      if (o === null) {\n        return null\n      } else {\n        while (true) {\n          if ((from === null || Y.utils.smaller(from, o.val.id)) && o.left !== null) {\n            // o is included in the bound\n            // try to find an element that is closer to the bound\n            o = o.left\n          } else if (from !== null && Y.utils.smaller(o.val.id, from)) {\n            // o is not within the bound, maybe one of the right elements is..\n            if (o.right !== null) {\n              o = o.right\n            } else {\n              // there is no right element. Search for the next bigger element,\n              // this should be within the bounds\n              return o.next()\n            }\n          } else {\n            return o\n          }\n        }\n      }\n    }\n    findNodeWithUpperBound (to) {\n      if (to === void 0) {\n        throw new Error('You must define from!')\n      }\n      var o = this.root\n      if (o === null) {\n        return null\n      } else {\n        while (true) {\n          if ((to === null || Y.utils.smaller(o.val.id, to)) && o.right !== null) {\n            // o is included in the bound\n            // try to find an element that is closer to the bound\n            o = o.right\n          } else if (to !== null && Y.utils.smaller(to, o.val.id)) {\n            // o is not within the bound, maybe one of the left elements is..\n            if (o.left !== null) {\n              o = o.left\n            } else {\n              // there is no left element. Search for the prev smaller element,\n              // this should be within the bounds\n              return o.prev()\n            }\n          } else {\n            return o\n          }\n        }\n      }\n    }\n    findSmallestNode () {\n      var o = this.root\n      while (o != null && o.left != null) {\n        o = o.left\n      }\n      return o\n    }\n    * findWithLowerBound (from) {\n      var n = this.findNodeWithLowerBound(from)\n      return n == null ? null : n.val\n    }\n    * findWithUpperBound (to) {\n      var n = this.findNodeWithUpperBound(to)\n      return n == null ? null : n.val\n    }\n    * iterate (t, from, to, f) {\n      var o\n      if (from === null) {\n        o = this.findSmallestNode()\n      } else {\n        o = this.findNodeWithLowerBound(from)\n      }\n      while (\n        o !== null &&\n        (\n          to === null || // eslint-disable-line no-unmodified-loop-condition\n          Y.utils.smaller(o.val.id, to) ||\n          Y.utils.compareIds(o.val.id, to)\n        )\n      ) {\n        yield * f.call(t, o.val)\n        o = o.next()\n      }\n      return true\n    }\n    * logTable (from, to, filter) {\n      if (filter == null) {\n        filter = function () {\n          return true\n        }\n      }\n      if (from == null) { from = null }\n      if (to == null) { to = null }\n      var os = []\n      yield * this.iterate(this, from, to, function * (o) {\n        if (filter(o)) {\n          var o_ = {}\n          for (var key in o) {\n            if (typeof o[key] === 'object') {\n              o_[key] = JSON.stringify(o[key])\n            } else {\n              o_[key] = o[key]\n            }\n          }\n          os.push(o_)\n        }\n      })\n      if (console.table != null) {\n        console.table(os)\n      }\n    }\n    * find (id) {\n      var n\n      return (n = this.findNode(id)) ? n.val : null\n    }\n    findNode (id) {\n      if (id == null || id.constructor !== Array) {\n        throw new Error('Expect id to be an array!')\n      }\n      var o = this.root\n      if (o === null) {\n        return false\n      } else {\n        while (true) {\n          if (o === null) {\n            return false\n          }\n          if (Y.utils.smaller(id, o.val.id)) {\n            o = o.left\n          } else if (Y.utils.smaller(o.val.id, id)) {\n            o = o.right\n          } else {\n            return o\n          }\n        }\n      }\n    }\n    * delete (id) {\n      if (id == null || id.constructor !== Array) {\n        throw new Error('id is expected to be an Array!')\n      }\n      var d = this.findNode(id)\n      if (d == null) {\n        // throw new Error('Element does not exist!')\n        return\n      }\n      this.length--\n      if (d.left !== null && d.right !== null) {\n        // switch d with the greates element in the left subtree.\n        // o should have at most one child.\n        var o = d.left\n        // find\n        while (o.right !== null) {\n          o = o.right\n        }\n        // switch\n        d.val = o.val\n        d = o\n      }\n      // d has at most one child\n      // let n be the node that replaces d\n      var isFakeChild\n      var child = d.left || d.right\n      if (child === null) {\n        isFakeChild = true\n        child = new N({id: 0})\n        child.blacken()\n        d.right = child\n      } else {\n        isFakeChild = false\n      }\n\n      if (d.parent === null) {\n        if (!isFakeChild) {\n          this.root = child\n          child.blacken()\n          child._parent = null\n        } else {\n          this.root = null\n        }\n        return\n      } else if (d.parent.left === d) {\n        d.parent.left = child\n      } else if (d.parent.right === d) {\n        d.parent.right = child\n      } else {\n        throw new Error('Impossible!')\n      }\n      if (d.isBlack()) {\n        if (child.isRed()) {\n          child.blacken()\n        } else {\n          this._fixDelete(child)\n        }\n      }\n      this.root.blacken()\n      if (isFakeChild) {\n        if (child.parent.left === child) {\n          child.parent.left = null\n        } else if (child.parent.right === child) {\n          child.parent.right = null\n        } else {\n          throw new Error('Impossible #3')\n        }\n      }\n    }\n    _fixDelete (n) {\n      function isBlack (node) {\n        return node !== null ? node.isBlack() : true\n      }\n      function isRed (node) {\n        return node !== null ? node.isRed() : false\n      }\n      if (n.parent === null) {\n        // this can only be called after the first iteration of fixDelete.\n        return\n      }\n      // d was already replaced by the child\n      // d is not the root\n      // d and child are black\n      var sibling = n.sibling\n      if (isRed(sibling)) {\n        // make sibling the grandfather\n        n.parent.redden()\n        sibling.blacken()\n        if (n === n.parent.left) {\n          n.parent.rotateLeft(this)\n        } else if (n === n.parent.right) {\n          n.parent.rotateRight(this)\n        } else {\n          throw new Error('Impossible #2')\n        }\n        sibling = n.sibling\n      }\n      // parent, sibling, and children of n are black\n      if (n.parent.isBlack() &&\n        sibling.isBlack() &&\n        isBlack(sibling.left) &&\n        isBlack(sibling.right)\n      ) {\n        sibling.redden()\n        this._fixDelete(n.parent)\n      } else if (n.parent.isRed() &&\n        sibling.isBlack() &&\n        isBlack(sibling.left) &&\n        isBlack(sibling.right)\n      ) {\n        sibling.redden()\n        n.parent.blacken()\n      } else {\n        if (n === n.parent.left &&\n          sibling.isBlack() &&\n          isRed(sibling.left) &&\n          isBlack(sibling.right)\n        ) {\n          sibling.redden()\n          sibling.left.blacken()\n          sibling.rotateRight(this)\n          sibling = n.sibling\n        } else if (n === n.parent.right &&\n          sibling.isBlack() &&\n          isRed(sibling.right) &&\n          isBlack(sibling.left)\n        ) {\n          sibling.redden()\n          sibling.right.blacken()\n          sibling.rotateLeft(this)\n          sibling = n.sibling\n        }\n        sibling.color = n.parent.color\n        n.parent.blacken()\n        if (n === n.parent.left) {\n          sibling.right.blacken()\n          n.parent.rotateLeft(this)\n        } else {\n          sibling.left.blacken()\n          n.parent.rotateRight(this)\n        }\n      }\n    }\n    * put (v) {\n      if (v == null || v.id == null || v.id.constructor !== Array) {\n        throw new Error('v is expected to have an id property which is an Array!')\n      }\n      var node = new N(v)\n      if (this.root !== null) {\n        var p = this.root // p abbrev. parent\n        while (true) {\n          if (Y.utils.smaller(node.val.id, p.val.id)) {\n            if (p.left === null) {\n              p.left = node\n              break\n            } else {\n              p = p.left\n            }\n          } else if (Y.utils.smaller(p.val.id, node.val.id)) {\n            if (p.right === null) {\n              p.right = node\n              break\n            } else {\n              p = p.right\n            }\n          } else {\n            p.val = node.val\n            return p\n          }\n        }\n        this._fixInsert(node)\n      } else {\n        this.root = node\n      }\n      this.length++\n      this.root.blacken()\n      return node\n    }\n    _fixInsert (n) {\n      if (n.parent === null) {\n        n.blacken()\n        return\n      } else if (n.parent.isBlack()) {\n        return\n      }\n      var uncle = n.getUncle()\n      if (uncle !== null && uncle.isRed()) {\n        // Note: parent: red, uncle: red\n        n.parent.blacken()\n        uncle.blacken()\n        n.grandparent.redden()\n        this._fixInsert(n.grandparent)\n      } else {\n        // Note: parent: red, uncle: black or null\n        // Now we transform the tree in such a way that\n        // either of these holds:\n        //   1) grandparent.left.isRed\n        //     and grandparent.left.left.isRed\n        //   2) grandparent.right.isRed\n        //     and grandparent.right.right.isRed\n        if (n === n.parent.right && n.parent === n.grandparent.left) {\n          n.parent.rotateLeft(this)\n          // Since we rotated and want to use the previous\n          // cases, we need to set n in such a way that\n          // n.parent.isRed again\n          n = n.left\n        } else if (n === n.parent.left && n.parent === n.grandparent.right) {\n          n.parent.rotateRight(this)\n          // see above\n          n = n.right\n        }\n        // Case 1) or 2) hold from here on.\n        // Now traverse grandparent, make parent a black node\n        // on the highest level which holds two red nodes.\n        n.parent.blacken()\n        n.grandparent.redden()\n        if (n === n.parent.left) {\n          // Case 1\n          n.grandparent.rotateRight(this)\n        } else {\n          // Case 2\n          n.grandparent.rotateLeft(this)\n        }\n      }\n    }\n    * flush () {}\n  }\n\n  Y.utils.RBTree = RBTree\n}\n","\nimport extendRBTree from './RedBlackTree'\n\nexport default function extend (Y) {\n  extendRBTree(Y)\n\n  class Transaction extends Y.Transaction {\n    constructor (store) {\n      super(store)\n      this.store = store\n      this.ss = store.ss\n      this.os = store.os\n      this.ds = store.ds\n    }\n  }\n  var Store = Y.utils.RBTree\n  var BufferedStore = Y.utils.createSmallLookupBuffer(Store)\n\n  class Database extends Y.AbstractDatabase {\n    constructor (y, opts) {\n      super(y, opts)\n      this.os = new BufferedStore()\n      this.ds = new Store()\n      this.ss = new BufferedStore()\n    }\n    logTable () {\n      var self = this\n      self.requestTransaction(function * () {\n        console.log('User: ', this.store.y.connector.userId, \"==============================\") // eslint-disable-line\n        console.log(\"State Set (SS):\", yield * this.getStateSet()) // eslint-disable-line\n        console.log(\"Operation Store (OS):\") // eslint-disable-line\n        yield * this.os.logTable() // eslint-disable-line\n        console.log(\"Deletion Store (DS):\") //eslint-disable-line\n        yield * this.ds.logTable() // eslint-disable-line\n        if (this.store.gc1.length > 0 || this.store.gc2.length > 0) {\n          console.warn('GC1|2 not empty!', this.store.gc1, this.store.gc2)\n        }\n        if (JSON.stringify(this.store.listenersById) !== '{}') {\n          console.warn('listenersById not empty!')\n        }\n        if (JSON.stringify(this.store.listenersByIdExecuteNow) !== '[]') {\n          console.warn('listenersByIdExecuteNow not empty!')\n        }\n        if (this.store.transactionInProgress) {\n          console.warn('Transaction still in progress!')\n        }\n      }, true)\n    }\n    transact (makeGen) {\n      var t = new Transaction(this)\n      try {\n        while (makeGen !== null) {\n          var gen = makeGen.call(t)\n          var res = gen.next()\n          while (!res.done) {\n            res = gen.next(res.value)\n          }\n          makeGen = this.getNextRequest()\n        }\n      } catch (e) {\n        if (this.y.emit != null) {\n          this.y.emit('error', e)\n        }\n        throw e\n      }\n    }\n    * destroy () {\n      yield * super.destroy()\n      delete this.os\n      delete this.ss\n      delete this.ds\n    }\n  }\n  Y.extend('memory', Database)\n}\n\nif (typeof Y !== 'undefined') {\n  extend(Y) // eslint-disable-line\n}\n"],"names":["extendRBTree","Y","N","val","color","_left","_right","_parent","id","Error","this","tree","parent","newParent","right","newRight","left","root","o","p","newLeft","n","RBTree","length","findWithLowerBound","findWithUpperBound","from","utils","smaller","next","to","prev","findNodeWithLowerBound","findNodeWithUpperBound","t","f","findSmallestNode","compareIds","call","filter","iterate","key","babelHelpers.typeof","JSON","stringify","push","o_","console","table","os","findNode","constructor","Array","d","child","blacken","isFakeChild","isBlack","isRed","_fixDelete","node","sibling","redden","rotateLeft","rotateRight","v","_fixInsert","uncle","getUncle","grandparent","extend","Transaction","store","ss","ds","Store","BufferedStore","createSmallLookupBuffer","Database","y","opts","requestTransaction","log","connector","userId","getStateSet","logTable","gc1","gc2","warn","listenersById","listenersByIdExecuteNow","transactionInProgress","makeGen","gen","res","done","value","getNextRequest","e","emit","AbstractDatabase"],"mappings":"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"}